package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"strconv"

	"github.com/TomasCruz/projecteuler"
)

/*
Problem 61; Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and
are generated by the following formulae:

Triangle 	  	P(3,n)=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  		P(4,n)=n^2 	  			1, 4, 9, 16, 25, ...
Pentagonal 	  	P(5,n)=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P(6,n)=n(2n−1) 	  		1, 6, 15, 28, 45, ...
Heptagonal 	  	P(7,n)=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P(8,n)=n(3n−2) 	  		1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
- The set is cyclic, in that the last two digits of each number is the first two digits of the next number
  (including the last number with the first).
- Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
  is represented by a different number in the set.
- This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
*/

func main() {
	var setSize int

	if len(os.Args) > 1 {
		setSize64, err := strconv.ParseInt(os.Args[1], 10, 64)
		if err != nil {
			log.Fatal("bad argument")
		}

		setSize = int(setSize64)
	} else {
		setSize = 6
	}

	projecteuler.Timed(calc, setSize, projecteuler.ConcurrentKind)
}

type intOker int

func (i intOker) Ok() bool {
	return i != 0
}

func calc(args ...interface{}) (result string, err error) {
	setSize := args[0].(int)
	kind := args[1].(int)
	cf := makeCyclicalFigurate(setSize)

	oneResultSolver := projecteuler.OneResultSolverFactory(kind, func(in interface{}) (projecteuler.Oker, error) {
		x, ok := in.(figurateNumber)
		if !ok {
			return nil, errors.New("not figurateNumber")
		}

		jr, _ := cf.jobFunction(x)
		return intOker(jr), nil
	})

	numJobs := len(cf.s)
	jobs := make(chan interface{}, numJobs)
	for _, f := range cf.s {
		jobs <- f
	}
	close(jobs)

	resultInterface, err := oneResultSolver.OneResultSolve(jobs)
	if err != nil {
		fmt.Println(err)
		return
	}

	if resultInterface == nil {
		result = "-1"
		return
	}

	rInt := int(resultInterface.(intOker))
	result = strconv.Itoa(rInt)
	return
}
